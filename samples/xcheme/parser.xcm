/**
 * A XCHEME Lang parser.
 */
import './lexer';

// Skip
skip ' ' | '\t' | '\v' | '\f' | '\r' | '\n';
skip '/*' & opt repeat (not '*/' then any) & '*/';
skip '//' & opt repeat (not '\n' then any);

// Parser
alias node ARGUMENT_OPERANDS as append <auto> next map {
  <202> T_NUMBER,
  <202> T_KEYWORDS.AUTO
};

alias node ARGUMENT_REFERENCE as append <201> next (T_IDENTIFIER & opt ARGUMENTS);
alias node ARGUMENT_LIST as (ARGUMENT_OPERANDS | ARGUMENT_REFERENCE) & opt (T_SYMBOLS.COMMA & ARGUMENT_LIST);
alias node ARGUMENTS_EXPRESSION as T_SYMBOLS.CHEVRON_OPEN & ARGUMENT_LIST & T_SYMBOLS.CHEVRON_CLOSE;
alias node ARGUMENTS as left prepend <249> next ARGUMENTS_EXPRESSION;

alias node PARAMETER_LIST as append <200> next symbol <305> T_IDENTIFIER & opt (T_SYMBOLS.COMMA & PARAMETER_LIST);
alias node PARAMETERS_EXPRESSION as scope (T_SYMBOLS.CHEVRON_OPEN & PARAMETER_LIST & T_SYMBOLS.CHEVRON_CLOSE);
alias node PARAMETERS as left append <248> right PARAMETERS_EXPRESSION;

alias node EXPRESSION as OR & opt THEN;
alias node GROUP as place (T_SYMBOLS.GROUP_OPEN & EXPRESSION & T_SYMBOLS.GROUP_CLOSE);
alias node OPERAND as MAP | RANGE | REFERENCE | ANY | EOS | STRING | GROUP;

alias <SYMBOL>
node IDENTIFIER as symbol <SYMBOL> (pivot <200> (T_IDENTIFIER & peek T_KEYWORDS.AS) & T_KEYWORDS.AS & place EXPRESSION);

alias node REFERENCE as append <201> (T_IDENTIFIER & opt ARGUMENTS);
alias node STRING as append <203> T_STRING;
alias node ANY as append <204> (T_KEYWORDS.ANY | T_SYMBOLS.ASTERISK);
alias node EOS as append <208> T_KEYWORDS.EOS;
alias node RANGE as place (T_KEYWORDS.FROM & STRING & pivot <205> (T_KEYWORDS.TO & STRING));
alias node MAP as scope (T_KEYWORDS.MAP & append <206> MAP_BLOCK);
alias node MAP_ENTRY as (ARGUMENTS & (IDENTIFIER <306> | place EXPRESSION)) | IDENTIFIER <306> | EXPRESSION;
alias node MAP_MEMBERS as append <207> next MAP_ENTRY & opt (T_SYMBOLS.COMMA & MAP_MEMBERS);
alias node MAP_BLOCK as T_SYMBOLS.OPEN_BRACES & MAP_MEMBERS & T_SYMBOLS.CLOSE_BRACES;

alias <L, R, N>
node <auto> DIRECTIONAL_OPERATOR as use <R> opt map {
  <L> T_KEYWORDS.LEFT,
  <R> T_KEYWORDS.RIGHT,
  <N> T_KEYWORDS.NEXT
};

alias node <auto> PLACE_OPERATOR as DIRECTIONAL_OPERATOR <216, 217, 218>;

alias node <auto> LEFT_APPEND as DIRECTIONAL_OPERATOR <219, 220, 221>;
alias node <auto> RIGHT_APPEND as DIRECTIONAL_OPERATOR <222, 223, 224>;
alias node <auto> NEXT_APPEND as DIRECTIONAL_OPERATOR <225, 226, 227>;

alias node <auto> LEFT_PREPEND as DIRECTIONAL_OPERATOR <228, 229, 230>;
alias node <auto> RIGHT_PREPEND as DIRECTIONAL_OPERATOR <231, 232, 233>;
alias node <auto> NEXT_PREPEND as DIRECTIONAL_OPERATOR <234, 235, 236>;

alias node <auto> UNARY as opt repeat append <auto> map {
   <213> T_KEYWORDS.NOT,
   <214> T_KEYWORDS.OPT,
   <215> T_KEYWORDS.REPEAT,
  <auto> T_KEYWORDS.PLACE & PLACE_OPERATOR,
  <auto> T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> T_KEYWORDS.LEFT & T_KEYWORDS.APPEND & opt ARGUMENTS & LEFT_APPEND,
  <auto> T_KEYWORDS.RIGHT & T_KEYWORDS.APPEND & opt ARGUMENTS & RIGHT_APPEND,
  <auto> T_KEYWORDS.NEXT & T_KEYWORDS.APPEND & opt ARGUMENTS & NEXT_APPEND,
  <auto> T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> T_KEYWORDS.LEFT & T_KEYWORDS.PREPEND & opt ARGUMENTS & LEFT_PREPEND,
  <auto> T_KEYWORDS.RIGHT & T_KEYWORDS.PREPEND & opt ARGUMENTS & RIGHT_PREPEND,
  <auto> T_KEYWORDS.NEXT & T_KEYWORDS.PREPEND & opt ARGUMENTS & NEXT_PREPEND,
   <237> T_KEYWORDS.PIVOT & opt ARGUMENTS,
   <238> T_KEYWORDS.SYMBOL & opt ARGUMENTS,
   <239> T_KEYWORDS.SCOPE,
   <240> T_KEYWORDS.USE & ARGUMENTS,
   <241> T_KEYWORDS.ERROR & ARGUMENTS,
   <242> T_KEYWORDS.WARN & ARGUMENTS,
   <243> T_KEYWORDS.HAS & ARGUMENTS,
   <244> T_KEYWORDS.SET & ARGUMENTS,
   <245> T_KEYWORDS.UNCASE,
   <246> T_KEYWORDS.PEEK
} & place ACCESS;

alias node ACCESS as OPERAND & opt repeat pivot <247> (T_SYMBOLS.PERIOD & OPERAND);
alias node AND as UNARY & opt repeat pivot <212> ((T_KEYWORDS.AND | T_SYMBOLS.AMPERSAND) & UNARY);
alias node OR as AND & opt repeat pivot <211> ((T_KEYWORDS.OR | T_SYMBOLS.VERTICAL_BAR) & AND);
alias node ELSE as pivot <210> (T_KEYWORDS.ELSE & EXPRESSION);
alias node THEN as pivot <209> (T_KEYWORDS.THEN & EXPRESSION & opt ELSE);

alias node <auto> ALIASES as opt PARAMETERS & map {
  <253> T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <303>,
  <254> T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <304>
};

alias node <auto> DIRECTIVES as map {
   <250> T_KEYWORDS.SKIP & EXPRESSION,
   <251> T_KEYWORDS.TOKEN & opt ARGUMENTS & IDENTIFIER <301>,
   <252> T_KEYWORDS.NODE & opt ARGUMENTS & IDENTIFIER <302>,
  <auto> T_KEYWORDS.ALIAS & ALIASES
};

alias node <auto> MODULES as map {
  <255> T_KEYWORDS.IMPORT & STRING,
  <256> T_KEYWORDS.EXPORT & (append <auto> DIRECTIVES | append <200> T_IDENTIFIER)
};

node <auto> STATEMENTS as (DIRECTIVES | MODULES) & T_SYMBOLS.SEMICOLON;